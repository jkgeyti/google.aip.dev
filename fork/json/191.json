{"text": "---\nid: 191\nstate: approved\ncreated: 2019-07-25\nplacement:\n  category: polish\n  order: 10\n---\n\n# File and directory structure\n\nA consistent file and directory structure, while making minimal difference\ntechnically, makes API surface definitions easier for users and reviewers to\nread.\n\n## Guidance\n\n**Note:** The following guidance applies to APIs defined in protocol buffers,\nsuch as those used throughout Google. While the spirit of this guidance applies\nto APIs defined using other specification languages or formats, some of the\nparticular recommendations might be irrelevant.\n\n### Syntax\n\nAPIs defined in protocol buffers **must** use `proto3` syntax.\n\n### Single package\n\nAPIs defined in protocol buffers **must** define each individual API in a\nsingle package, which **must** end in a version component. For example:\n\n```proto\nsyntax = \"proto3\";\n\npackage google.cloud.translation.v3;\n```\n\nGoogle APIs **must** reside in a directory that matches the protocol buffer\n`package` directive. For example, the package above dictates that the directory\nbe `google/cloud/translation/v3`.\n\n### File names\n\nIt is often useful to divide API definitions into multiple files. File names\n**must** use `snake_case`.\n\nAPIs **should** have an obvious \"entry\" file, generally named after the API\nitself. An API with a small number of discrete services (Google Cloud Pub/Sub's\n`Publisher` and `Subscriber` is a good example) **may** have a separate entry\nfile per service.\n\nAPIs with only one file **should** use a filename corresponding to the name of\nthe API.\n\nAPI `service` definitions and associated RPC request and response `message`\ndefinitions **should** be defined in the same file.\n\nBear in mind that the file names often become module names in client libraries,\nand customers use them in `import` or `use` statements. Therefore, choosing a\ndescriptive and language keyword-free filename does matter. For example, a file\ncalled `import.proto` may be problematic in Python.\n\n**Note:** The version **must not** be used as a filename, because this creates\nbizarre imports in client libraries. Filenames such as `v3.proto` or\n`v1beta1.proto` are prohibited.\n\n### File layout\n\nIndividual files **should** place higher level and more important definitions\nbefore lower level and less important definitions.\n\nIn a proto file, components **should** be in the following order, and each of\nthese **should** be separated by a blank line:\n\n- Copyright and license notice (if applicable).\n- The proto `syntax` statement.\n- The proto `package` statement.\n- Any `import` statements, in alphabetical order.\n- Any file-level `option` statements.\n- Any `service` definitions.\n  - Methods **should** be grouped by the resource they impact, and standard\n    methods **should** precede custom methods.\n- Resource `message` definitions. A parent resource **must** be defined before\n  its child resources.\n- The RPC request and response `message` definitions, in the same order of the\n  corresponding methods. Each request message **must** precede its\n  corresponding response message (if any).\n- Any remaining `message` definitions.\n- Any top-level `enum` definitions.\n\n### Packaging annotations\n\nProtocol buffers ships with annotations to declare the package or namespace\n(depending on the vocabulary of the target language) of the generated files.\nFor example, setting `go_package` or `csharp_namespace` will override the\ninferred package name.\n\nWhen defining APIs, the following rules apply:\n\n- Java\n  - The `java_package` annotation **must** be set. The correct value is usually\n    the proto package with the appropriate TLD prefixed. Example:\n    `com.google.example.v1`.\n  - The `java_multiple_files` annotation **must** be set to `true`.\n  - The `java_outer_classname` annotation **must** be set, and **should** be\n    set to the name of the proto filename, in `PascalCase`, with `Proto`\n    appended. Example: `LibraryProto`.\n- Other languages\n  - Package or namespace directives for other languages **must** be set either\n    in every file in the proto package, or none of them. If they are set, the\n    values **must** be identical in every file.\n  - If any part of the protobuf package is a compound name (such as\n    accessapproval), C#, Ruby and PHP options **must** be specified in order\n    to take account of the word breaks using PascalCase (UpperCamelCase).\n    Example:\n    ```proto\n    option csharp_namespace = \"Google.Cloud.AccessApproval.V1\";\n    option php_namespace = \"Google\\\\Cloud\\\\AccessApproval\\\\V1\";\n    option ruby_package = \"Google::Cloud::AccessApproval::V1\";\n    ```\n\nAll packaging annotations **should** be specified in alphabetical order of\nname.\n\n**Important:** While languages other than Java have sensible defaults for APIs\nwhich don't include compound names, be aware that _adding_ this annotation\n(with a value not equivalent to the default) constitutes a breaking change in\nthat language. When releasing protos, be sure that omissions are intentional.\n\n## Changelog\n\n- **2023-02-24**: Added guidance on protobuf syntax.\n- **2022-10-18**: Added guidance on Ruby/PHP/C# options.\n- **2019-11-18**: Added guidance on the packaging annotations.\n"}