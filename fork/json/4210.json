{"text": "---\nid: 4210\nstate: approved\ncreated: 2018-06-22\njs_scripts:\n  - /assets/js/graphviz/viz.js\n  - /assets/js/graphviz/lite.render.js\n  - /assets/js/aip/aip-graphviz.js\n---\n\n# Client library generators\n\nAPI guidelines exist in order to promote simple, intuitive, and consistent\nAPIs. Users familiar with APIs that generally adhere to AIP guidance are able\nto take what they learn in prior APIs and apply it to new ones.\n\nClient libraries provide a mechanism for users to get started with APIs more\nquickly, by simplifying common concerns (such as auth) and by a language-native\nway to call API endpoints and receive language-native responses. However, for\nthese libraries to provide the most value, they also must be simple, intuitive,\nand consistent. Code generators provide a means for producing consistent client\nlibraries at scale.\n\nCode generators following the standards in these AIPs are known as \"generated\nAPI client generators\", or _GAPIC generators_ for short. The resulting\nlibraries are colloquially called _GAPICs_.\n\n**Note:** Because this AIP describes guidance and requirements in a\nlanguage-neutral way, it uses generic terminology which may be imprecise or\ninappropriate in certain languages or environments (for example, the use of the\nterm `class` even though languages such as Go do not have classes). This AIP's\nparticular use of vocabulary is best understood as an explanation of\nprinciples, and precise adherence to exact vocabulary in this AIP is not an\nexpectation.\n\n## Guidance\n\nThe general flow of code generation for client libraries and supporting code in\nmost supported languages is outlined below.\n\n**Note:** Exceptions to this pattern are typically due to use of a unique stack\ne.g. Node.js use of `protobuf.js` and `grpc-node` which don't have code\ngeneration, or Python using a protobuf wrapper in `proto-plus-python`, but the\ngeneral GAPIC flow remains the same.\n\n```graphviz\ndigraph {\n  node [ style=\"filled,solid\" shape=box fontname=\"Roboto\" ];\n  splines=ortho;\n  nodesep=0.3;\n  center=true;\n\n  proto [ label=\"API Protobuf\\nDescriptors\" shape=rectangle fillcolor=aliceblue ];\n\n  subgraph cluster_code_generators {\n    rank = same;\n    style = filled;\n    fillcolor = lightgrey;\n    node [ shape=oval ];\n\n    protobuf [ label=\"protobuf\\ngenerator\" fillcolor=deepskyblue3 ];\n    grpc [ label=\"gRPC\\ngenerator\" fillcolor=gold3 ];\n    gapic [ label=\"GAPIC\\ngenerator\" fillcolor=darkseagreen ];\n  }\n\n  proto -> protobuf;\n  proto -> grpc;\n  proto -> gapic;\n\n  subgraph cluster_generated_code {\n    rank = same;\n    style = filled;\n    fillcolor = lightgrey;\n    node [ shape=rectangle ];\n\n    protobuf_output [ label=\"Message & Enum\\nCode\" fillcolor=deepskyblue3 ];\n    grpc_output [ label=\"Server & Client\\nStubs\" fillcolor=gold3 ];\n    gapic_output [ label=\"Google API\\nClient\" fillcolor=darkseagreen ];\n  }\n  \n  protobuf -> protobuf_output;\n  grpc -> grpc_output;\n  gapic -> gapic_output;\n\n  assembly [ label=\"Package\\nassembly\" shape=oval fillcolor=aliceblue ];\n  \n  protobuf_output -> assembly\n  grpc_output -> assembly\n  gapic_output -> assembly\n\n  assembled_package [ label=\"Package of\\ngenerated code\" fillcolor=aliceblue ];\n\n  assembly -> assembled_package\n}\n```\n\nThe following sections focus on the \"GAPIC generator\" in the above diagram.\n\n### Protobuf plugins\n\nThe protobuf compiler, `protoc`, supports a [plugin system][0] for code\ngeneration. The plugin system allows plugins to be written _in_ and _for_ any\nlanguage.\n\nCode generators **must** be implemented as `protoc` plugins. The following\nrules apply to the implementation of a client library generator as a `protoc`\nplugin:\n\n- The plugin  **should** be written in the language being targeted for\n  generation.\n- `protoc` expects plugins to be an executable in `$PATH`, and named\n  `protoc-gen-{plugin_name}`, corresponding to the `--{plugin_name}_out` option\n  sent to the `protoc` executable. As such:\n  - the plugin executable **should** be named `protoc-gen-{lang}_gapic`\n  - the plugin option  **should** follow the convention `--{lang}_gapic_out`\n- The plugin **must not** leverage `protoc` \"insertion points\". Despite the\n  `protoc` plugin documentation indicating the existence of insertion points,\n  their use is unsupported and discouraged by the Protobuf team.\n\n### CLI options\n\nCode generators **should** be able to run without any options or flags if at\nall possible, and be able to generate a valid library from only the protos. If\noptions are required, `protoc` allows them to be passed as\n`--{plugin_name}_opt`, and the string provided here becomes set as the\n`parameter` string on the `CodeGeneratorRequest`.\n\n**Important:** The `CodeGeneratorRequest.parameter` value is a comma-delimited\nstring of _all_ associated plugin option values that appear at execution time.\nThis means that commas cannot be used to delimit list-like plugin option values.\n\nCode generators **must not** rely on environment variables for configuration.\n\n## Expected behavior\n\nThis section outlines the expected behavioral attributes of the _output of_ the\nclient library generator (in other words: the libraries that the generators\nwrite). Client libraries **must** implement these concepts in order to be\nconsidered complete.\n\n### Messages and Enums\n\nClient library generators **should not** generate code for `message` or `enum`\ndescriptors which are already generated by the Protobuf-provided code\ngenerators.\n\n### Services and methods\n\nEach of the `service` and `rpc` directives in the requested protos **must** be\nrepresented in the client library output, unless the language or transport is\nunable to support it.\n\n**Note:** While how to accomplish this may vary from language to language, in\nmost classical languages it is probably a class for each service, containing\nmethods for each RPC.\n\n- The classes generated for each `service` directive **must** honor the\n  `google.api.default_host` annotation if it is provided, and use that host as\n  the default hostname. These classes **should** provide a mechanism for the\n  end user to override the hostname.\n  - If the `google.api.default_host` annotation is not present on the `service`\n    directive, then the generated class **should** require a hostname when it\n    is instantiated.\n- Additionally, if the classes generated for each service support using OAuth\n  and service credentials, they **must** honor the `google.api.oauth_scopes`\n  annotation (if it is provided), and use these scopes by default.\n- Services that have set the `deprecated` protobuf option to `true` **should** have an\n  equivalent deprecation tag generated in the generated class. If applicable, this\n  tag may include a comment that specifies when the service will be removed, which\n  is typically the next major version update. Similarly, RPCs with this option set\n  to `true` **should** have their generated language method(s) marked as deprecated.\n- Finally, service classes **must** also accept credentials, which are used\n  appropriately when requests are made. (Accepting a custom gRPC channel\n  satisfies this requirement.)\n- Code generators **must not** generate client _stub_ classes, that would\n  normally be generated by gRPC, in addition to client library classes.\n\n### Long-running operations\n\n<!-- TODO(1145): Move to its own client library AIP. -->\n\nAn RPC is considered to be a \"long-running\" RPC if (and only if) the RPC's\nreturn type is [`google.longrunning.Operation`][3]. Any API which has one or\nmore RPCs returning an `Operation` is expected to implement the `Operations`\nservice.\n\nBecause the `response` and `metadata` fields in [`Operation`][3] are of the\ntype [`google.protobuf.Any`][4], it is necessary to know what message to use to\ndeserialize them. This is annotated on the RPC using the\n[`google.longrunning.operation_info`][5] annotation.\n\n**Note:** The values in this struct are _strings_, not message objects; the\ncode generator uses the string to determine the appropriate message to use.\nStrings with no period (`.`) character refer to a message in the same proto\npackage.\n\nCode generators **should** fail with an error if a type is provided in the\n[`operation_info`][5] annotation which was not imported, or if no response type\nor metadata type is provided. Code generators **should** fail with an error if\n_either_ the `response_type` or `metadata_type` keys are omitted.\n\nClient libraries **must** honor the LRO interface; if an RPC has an\n[`Operation`][3] as its return type, the generated method **must** intercept it\nand return an appropriate idiomatic object for resolving the LRO (such as a\n`Future` or `Promise` bound to the underlying [`Operation`][3] object).\n\n### Streaming\n\nClient libraries **must** implement streaming to the extent that their\nsupporting transports allow. An RPC is considered to be streaming if the\n`stream` keyword is present on the argument or response type. This is present\nin the [`MethodDescriptorProto`][6] message using the `client_streaming` and\n`server_streaming` keys.\n\n<!-- prettier-ignore-start -->\n[0]: https://protobuf.dev/reference/other\n[1]: https://github.com/google/protobuf/blob/master/src/google/protobuf/compiler/plugin.proto\n[2]: https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto\n[3]: https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto#L122\n[4]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto\n[5]: https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto#L222\n[6]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/descriptor.proto#L269\n<!-- prettier-ignore-end -->\n\n## Changelog\n\n- **2023-06-22**: Added code gen diagram, message/enum guidance, and cleaned up\n  plugin & option guidance."}