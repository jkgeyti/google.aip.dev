{"text": "---\nid: 2715\nstate: reviewing\ncreated: 2018-09-10\n---\n\n# Documenting authorization changes\n\nAuthorization is critical to manage well. Understanding an API includes\nunderstanding not only what operations do, but when one is allowed to do them.\nAuthorization changes, either new authorization constructs or new uses of\nexisting authorization constructs, should be easy to find in a design rather\nthan scattered through the document in individual sections.\n\nIn order to make it easy to see what (if any) authorization constructs are\nbeing modified in your design, we want to be able to find them in a single,\nclear place.\n\n**Note:** This is _not_ talking about RPC-level permissions, like those covered\nby `RpcSecurityPolicy`, but about authorization constructs used by your API for\nits own purposes.\n\n## Definitions\n\nThere are a couple of common types of authorization construct:\n\nA **role** refers to an authorization construct which is granted to an\n_identity_ or an _identity group_ on a _resource_. The most well known examples\nof roles in G Suite are the `commenter`, `reader`, `writer`, and `owner` roles\nfrom Drive.\n\nA **permission** refers to an authorization construct which is used to check\nwhether a particular _identity_ can execute some _operation_. For example, to\ncheck whether the current user can delete a file, the application may check\nwhether the user has the `file.delete` permission on the file. Permissions are\nmost often assigned to roles, so that only roles are granted to identities or\nidentity groups, but some systems allow permissions to be granted directly.\nApplications often only use each permission to authorize a single operation on\na resource, but there are cases where an application may use a permission to\nauthorize multiple different operations.\n\nWithin an application, authorization checks are made using only one of these\nauthorization constructs (typically permissions, if the application has that\nconcept). For example, in order to determine if a user can read a document, an\napplication would _either_ check whether the user has a `doc.read` permission\n_or_ has the `reader` role, but not both.\n\n## Guidance\n\nIf your design creates new authorization constructs or extends/modifies the use\nof any existing authorization constructs, you **must** have a separate section\nin your design document that describes this. You **may** additionally discuss\nthese in any other place in your document.\n\nIt is not important whether this is a top-level section or subsection. It is\nimportant that all such changes are listed together in a distinct section so\nthey are easy to find and analyze.\n\nIf the identifier of an authorization construct that is new or modified is\nvisible to users or developers, the way that it is identified should also be in\nyour document. Examples of this are:\n\n- If access is granted using roles and a new role is being added, the way that\n  the role is identified in the role granting RPCs should be in your document.\n- If there is an API that allows permissions assigned to roles to be\n  manipulated, the way that the permission is identified in the role\n  manipulation RPCs should be in your document.\n"}