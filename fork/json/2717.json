{"text": "---\nid: 2717\nstate: reviewing\ncreated: 2018-09-10\n---\n\n# Patterns for generic fields\n\nDevelopers have several options for how to represent generic values in proto\nmessages. There are reasons to choose one over the other. Understanding them\nwill lead to better and more consistent APIs.\n\n## Guidance\n\nAPIs **should** follow a consistent application of `oneof` vs.\n`map<string, Foo>` vs. `Any` vs. `Struct`.\n\n### `oneof`\n\nA `oneof` is used to create a restriction on a set of optional fields,\nenforcing that only one of them may be set (these fields are still separate\nindividual fields). A common pattern is to have a message that contains a\nsingle `oneof` collection of various message types. Such a `oneof` message is\nconceptually similar to a C `union`, or C++ `std::variant`. These **should** be\nused in most places where a generic message type is needed, in preference to\nother approaches.\n\n**Note:** Adding additional possible values to an existing `oneof` is a\nnon-breaking change, but moving existing fields into or out of a `oneof` is\nbreaking (it creates a backwards-incompatible change in Go protobuf stubs).\n\n### `map<string, Foo>`\n\nIf a more generic structure is needed, a map of strings to objects **may** be\nused. Such a map is represented by a normal JSON object, such as\n`{\"a\": \"foo\", \"b\": \"bar\"}`. The downside to such maps is that they are limited\nto flat structures, and they can be difficult to work with because many string\nconstants may be needed.\n\n### `Any`\n\nAn [`Any`][any] allows any message to be packed into the field. This is\nconceptually similar to a \"bytes\" field containing a serialized message. The\nadvantage of an `Any` is that a user-defined proto message can be stored along\nwith type information. The user must be able to know which kind of object is in\nthe `Any`, which complicates the design. The disadvantage is that working with\nand debugging any protos is much more complicated since the code may or may not\nknow how to deserialize the packed message. Also, the developer must contend\nwith unexpected types of messages in the `Any`.\n\n`Any` **should not** be used as a request parameter. Request parameters will\neither be a fixed set of types, in which case a `oneof` **should** be used, or\na type descriptor would need to be sent along, in which case a struct\n**should** be used, which achieves essentially the same thing with much simpler\nsemantics.\n\n<!-- prettier-ignore -->\n[any]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto\n\n### `Struct`\n\nThe [`Struct`][struct] message can be used to represent arbitrary nested JSON.\nFor example, given the following code:\n\n```java\nStruct.Builder builder = Struct.newBuilder();\nValue town = Value.newBuilder().setStringValue(\"Springfield\").build();\nValue population = Value.newBuilder().setNumberValue(273).build();\nbuilder.putFields(\"town\", town);\nbuilder.putFields(\"population\", population);\nStruct survey = builder.build();\n```\n\n`survey` would serialize as the actual JSON\n`{\"town\": \"Springfield\": \"population\": 273}`. This message type is fairly\nuncommon, and **should** only be used rarely.\n\n<!-- prettier-ignore -->\n[struct]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto\n"}