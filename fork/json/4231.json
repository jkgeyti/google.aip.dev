{"text": "---\nid: 4231\nstate: approved\ncreated: 2018-06-22\n---\n\n# Parsing resource names\n\nIn resource-oriented design ([AIP-121][]), _resources_ represent the primary\nnouns within APIs, and often have _resource names_ ([AIP-122][]). These\nresource names convey information about the structure and hierarchy of the\nresource structure in that API. APIs accept these resource names as parameters\nwhen retrieving and modifying resources, and when referencing them in other\nobjects. However, users may struggle to piece together resource names to send,\nand client libraries have the opportunity to make this easier through the use\nof helper components.\n\n## Guidance\n\nClient libraries **may** provide helper classes or functions to make\nconstructing resource names more straightforward. However, client libraries\nthat choose to implement this feature **must** always accept the plain strings\nalso, for two reasons:\n\n1. An existing API that adds resource descriptor annotations should be able to\n   do so without incurring a breaking change.\n2. Resource name patterns occasionally evolve, and users need to be able to\n   send and receive resource names that a statically-compiled client library\n   may not yet acknowledge.\n\n### Resource messages\n\nA resource in an API always has a message that describes the representation of\nthat resource in that API. Client library generators are able to recognize\nthese messages when they are annotated with the `google.api.resource`\nannotation:\n\n```proto\n// A representation of a Topic in Pub/Sub.\nmessage Topic {\n  option (google.api.resource) = {\n    type: \"pubsub.googleapis.com/Topic\"\n    pattern: \"projects/{project}/topics/{topic}\"\n  };\n\n  // name and so on...\n}\n```\n\n- The `type` field provides the [unified resource type][aip-123] name.\n  - Client libraries **should** name their helper component based on this\n    value.\n  - The universal resource type usually (but not always) ends with a name that\n    matches the name of the message.\n- The `pattern` field provides the structure of this resource type's names.\n  - The components in braces represent variable substitutions. Client libraries\n    implementing this feature **must** accept variables based on these names\n    when building resource name strings.\n  - Variable substitution names are usually specified in `snake_case`, but this\n    is not guaranteed. Client libraries **should** be able to accept any\n    annotation that uses any coherent case system.\n  - Patterns are usually slash-separated, but this is not guaranteed. Client\n    libraries **should** use string interpolation to piece together the\n    resource name.\n- The defining message is expected to contain a field called `name`, which is\n  the field holding the resource name.\n  - APIs are able to override the name field's name by setting the `name_field`\n    property on the `google.api.resource` annotation.\n  - Code generators **should** fail with an error if a message is annotated as\n    a resource and has no name field (either the default of `name` or the field\n    provided in the `name_field` property of the annotation). Code generators\n    **should** also fail with an error if the field is not a string).\n\n### Multi-pattern resources\n\nOccasionally, a resource may have more than one pattern. The common case for\nthis is when a resource can live under more than one parent type. In this\nsituation, the `pattern` field on the annotation can be specified more than\nonce:\n\n```proto\nmessage LogEntry {\n  option (google.api.resource) = {\n    type: \"logging.googleapis.com/Log\"\n    pattern: \"projects/{project}/logs/{log}\"\n    pattern: \"organizations/{organization}/logs/{log}\"\n    pattern: \"folders/{folder}/logs/{log}\"\n    pattern: \"billingAccounts/{billing_account}/logs/{log}\"\n  };\n\n  // name and so on...\n}\n```\n\nIf necessary, client libraries **may** create a separate helper component for\neach pattern, and **may** provide a rollup component.\n\n### Resources without messages\n\nOccasionally, a resource may be implicitly defined by an API service, but not\nhave an explicit message representing that resource. (For example, the\n[Firestore API][] defines databases as a common ancestor to its resources, but\ndoes not define a database message.)\n\nIn this situation, APIs annotate the resource on the _file_ instead of on a\n_message_, using the `google.api.resource_definition` annotation:\n\n```proto\noption (google.api.resource_definition) = {\n  type: \"firestore.googleapis.com/Database\"\n  pattern: \"projects/{project}/databases/{database}\"\n};\n```\n\nClient library generators implementing this feature **must** generate the same\nutility components that would be generated when encountering a\n[resource message](#resource-messages).\n\n### Referencing other resources\n\nAPIs often use resource names for referencing fields defined elsewhere. This is\nparticularly common with the request messages for the standard methods, such as\n[Get][aip-131] and [Update][aip-134]; however, resources and other structures\nuse resource name strings as references also.\n\nClient libraries implementing this feature **should** also provide their helper\ncomponents when resources are being referenced. Client libraries are able to\nrecognize these fields when they are annotated with the\n`google.api.resource_reference` annotation:\n\n```proto\nmessage GetTopicRequest {\n  // The name of the topic to retrieve.\n  string name = 1 [(google.api.resource_reference) = {\n    type: \"pubsub.googleapis.com/Topic\"\n  }];\n}\n```\n\nThe resource reference references the [unified resource type][aip-123] name.\n\nSome methods also refer to the _parent_ of a type, and in situations where\nthere are multiple parents, it is repetitive and error-prone to refer to each\nindividual parent type. In these situations, API producers specify `child_type`\nrather than `type`:\n\n```proto\nmessage ListLogEntriesRequest {\n  // The collection of log entries to list.\n  string parent = 1 [(google.api.resource_reference) = {\n    child_type: \"logging.googleapis.com/Log\"\n  }];\n}\n```\n\nIn this situation, client library generators implementing this feature **must**\nderive the set of parent resources from the child type. Client library\ngenerators **must** fail with an error if both `type` and `child_type` are\nprovided.\n\n### Referencing an arbitrary resource\n\nOccasionally, a field may reference an arbitrary resource. In this case, APIs\nuse the special value `*` in their resource reference.\n\n```proto\nmessage GetIamPolicyRequest {\n  string resource = 1 [(google.api.resource_reference) = {\n    type: \"*\"\n  }];\n}\n```\n\nIn this situation, client library generators implementing this feature **may**\nprovide a generic utility class or function to address that resource name.\n\n### Complex resource ID path segments\n\n**Warning:** Complex resource ID path segments **should not** generally be used\nin new APIs. [AIP-124][] contains advice on handling many-to-many associations.\n\nResource patterns **may** contain resource ID path segments which contain\nmultiple pattern variables separated by a variable separator:\n\n```proto\nmessage FeedItemTarget {\n  option (google.api.resource) = {\n    type: \"googleads.googleapis.com/FeedItemTarget\"\n    pattern: \"customers/{customer}/feedItemTargets/{feed}~{feed_item}\"\n  };\n\n  // name and other fields...\n}\n```\n\nThis is only used when the resource ID is naturally in multiple parts and it is\nuseful for the user to be able to manipulate the separate ID parts.\n\n- A variable separator is one character long, and **must** only one of: `_`,\n  `-`, `.`, `~` (underscore, hyphen, period, tilde).\n- A variable separator **must not** appear before the first pattern variable or\n  after the last pattern variable.\n\n### Backwards compatibility\n\nClient libraries implementing helper components for resources **must** conform\nto the following backwards-compatibility expectations:\n\n- The addition of a `google.api.resource` annotation on an existing message\n  **must** be a backwards-compatible change.\n- An existing resource **must** be able to add new patterns (including the \"\\*\"\n  wildcard pattern) without breaking changes as long as the following\n  conditions are met:\n  - New patterns must always be appended to the list.\n  - New patterns must use a distinct sequence of collection identifiers (see\n    [AIP-122][]) compared with all existing patterns within this resource.\n- The identifiers within the pattern variables are final - they **must not** be\n  changed. These identifiers are used in the surface of generated client\n  libraries.\n- The addition of a `google.api.resource_reference` annotation on an existing\n  field **must** be a backwards-compatible change.\n\nNote: The `ORIGINALLY_SINGLE_PATTERN` and `FUTURE_MULTI_PATTERN` flags are\ndeprecated, and must not be used.\n\n## Further reading\n\n- For more on resource names and patterns, see [AIP-122][].\n- For more on unified resource types, see [AIP-123][].\n\n## Changelog\n\n- **2022-10-28**: Pattern variables are considered final\n- **2020-09-14**: Disallow simultaneous use of both `type` and `child_type`.\n- **2020-05-14**: Added complex resource ID path segments.\n- **2020-05-07**: Updated backwards compatibility guidance.\n- **2019-09-16**: Added guidance for resources without messages.\n\n<!-- prettier-ignore-start -->\n[aip-121]: ../0121.md\n[aip-122]: ../0122.md\n[aip-123]: ../0123.md\n[aip-124]: ../0124.md\n[aip-131]: ../0131.md\n[aip-134]: ../0134.md\n[firestore api]: https://github.com/googleapis/googleapis/tree/master/google/firestore/v1\n<!-- prettier-ignore-end -->\n"}