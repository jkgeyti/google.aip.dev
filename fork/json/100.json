{"text": "---\nid: 100\nstate: approved\ncreated: 2018-08-27\nplacement:\n  category: process\n  order: 10\njs_scripts:\n  - /assets/js/graphviz/viz.js\n  - /assets/js/graphviz/lite.render.js\n  - /assets/js/aip/aip-graphviz.js\n---\n\n# API Design Review FAQ\n\nAPI design review exists to ensure a simple, intuitive, and consistent API\nexperience throughout our API corpus.\n\n## Do I need API design approval?\n\n**TL;DR:** You usually need API design approval if you are launching an API\nthat users can code against (either now or in the future) at the beta or GA\nquality level.\n\nAPI design review is fundamentally about ensuring we provide a simple and\nconsistent experience for our users, and therefore is only expected for APIs\nthat users code directly against.\n\nThe following flowchart illustrates whether or not your API needs to go through\nthe design review process:\n\n```graphviz\ndigraph {\n  node [ style=\"filled,solid\" shape=box fontname=\"Roboto\" ];\n  graph [ splines=ortho, nodesep=0.2 ];\n\n  audience [ label=\"Who should code directly\\nagainst this API?\"\n             shape=diamond fillcolor=bisque ];\n\n  subgraph audience_responses {\n    rank = \"same\";\n    node [ shape=oval fillcolor=orange ];\n\n    googlers [ label=\"Googlers\\nOnly\" fillcolor=lightcoral ];\n    public [ label=\"Anyone\" fillcolor=limegreen ];\n    partners [ label=\"Partners\\nOnly\" fillcolor=deepskyblue ];\n\n    partners -> public -> googlers [ style=invisible arrowhead=none ];\n  }\n\n\n  subgraph and_ever {\n    rank = \"same\";\n    node [ shape=diamond fillcolor=bisque ];\n\n    forever_partners [ label=\"Forever?\" shape=diamond fillcolor=bisque ];\n    forever_googlers [ label=\"Forever?\" shape=diamond fillcolor=bisque ];\n  }\n\n  subgraph forever_responses {\n    rank = \"same\";\n    node [ shape=oval fillcolor=orange ];\n\n    forever_partners_yes [ label=\"Yes\" fillcolor=deepskyblue ];\n    forever_no [ label=\"No, anyone\\neventually\" fillcolor=limegreen ];\n    forever_googlers_yes [ label=\"Yes\" fillcolor=lightcoral ];\n  }\n\n  release_level [ label=\"What release\\nlevel?\" shape=diamond fillcolor=bisque ];\n\n  # Not required is not in the subgraph with the other outcomes because\n  # it makes the graph much smaller if it can be higher in the image.\n\n  subgraph release_levels {\n    rank = \"same\";\n    node [ shape=oval ];\n\n    alpha [ label=\"Alpha\" fillcolor=darkorange ];\n    beta [ label=\"Beta\" fillcolor=goldenrod1 ];\n    ga [ label=\"GA\" fillcolor=limegreen ];\n\n    alpha -> beta -> ga [ style=invisible arrowhead=none ];\n  }\n\n  changes [ label=\"Any changes\\nfrom beta?\" shape=diamond fillcolor=bisque ];\n\n  subgraph changes_bool {\n    rank = \"same\";\n    node [ shape=oval ];\n\n    changes_yes [ label=\"Yes\" fillcolor=goldenrod1 ];\n    changes_no [ label=\"No\" fillcolor=limegreen ];\n  }\n\n  subgraph outcome {\n    rank = \"same\";\n    node [ style=\"rounded,filled\" ];\n    fyi [ label=\"FYI\" fillcolor=lightblue ];\n    recommended [ label=\"Recommended\" fillcolor=limegreen ];\n    required [ label=\"\u26a0 Required\" fillcolor=goldenrod1 ];\n    not_required\n      [ label=\"Not Required\" fillcolor=lightgrey style=\"rounded,filled\" ];\n    recommended -> required -> fyi -> not_required\n      [style=invisible arrowhead=none];\n  }\n\n  audience -> googlers [ arrowhead=none style=dashed color=grey ];\n  audience -> partners [ arrowhead=none ];\n  audience -> public [ arrowhead=none ];\n  partners -> forever_partners;\n  googlers -> forever_googlers [ style=dashed color=grey ];\n  public -> release_level;\n  forever_partners -> forever_partners_yes [ arrowhead=none ];\n  forever_googlers -> forever_googlers_yes\n    [ arrowhead=none style=dashed color=grey ];\n  forever_partners -> forever_no [ arrowhead=none ];\n  forever_googlers -> forever_no [ arrowhead=none ];\n  forever_partners_yes -> recommended;\n  forever_googlers_yes -> not_required [ style=dashed color=grey ];\n  forever_no -> release_level;\n  release_level -> alpha [ arrowhead=none ];\n  release_level -> beta [ arrowhead=none ];\n  release_level -> ga [ arrowhead=none ];\n  alpha -> recommended;\n  beta -> required;\n  ga -> changes;\n  changes -> changes_yes [ arrowhead=none ];\n  changes -> changes_no [ arrowhead=none ];\n  changes_yes -> required;\n  changes_no -> fyi;\n}\n```\n\n### Who should code directly against it?\n\nOne of the more complex questions is, \"Who should code directly against this\nAPI?\" API design review is primarily concerned about the API's audience. This\nmeans we care about who is permitted to write their own HTTP/gRPC calls against\nthe service, and who is able to see the documentation. (We do _not_ care about\nquestions such as whether the service is exposed on the public network.)\n\nDesign review is expected if the general public is intended to read\ndocumentation and write code that interacts with the service.\n\nThe following situations **do not** require design review:\n\n- An API which will only ever be used by Googlers, or internal tools (for\n  example, Pantheon).\n- An API which will only ever be called by an executable program released by\n  Google (even if the API could be reverse-engineered from the executable).\n- An API which will only ever be called by a single customer or small set of\n  customers under contract, and which will _never_ be made more widely\n  available. (Design review is still recommended in this case, but not\n  required.)\n\n### Alpha\n\nFor alpha, API design review is optional but recommended. It may often make\nsense to endeavor to get initial feedback from customers quickly, and launching\nan alpha can be a way of gaining data to determine the best answer to some\nusability questions; therefore, bypassing review may be expedient. On the other\nhand, launching an alpha requires building an implementation which then takes\nengineering effort to update if the API design review at the beta stage raises\nconcerns. Because API design review can precede implementation work, we\nrecommend a design review for alpha.\n\n## Why is design review important?\n\n**TL;DR:** Product excellence.\n\nOur design review process exists to ensure that the APIs that we present to\ncustomers are **simple**, **intuitive**, and **consistent**. Your reviewer\napproaches your API from the standpoint of a na\u00efve user, thinks through the\nresources and actions that your API provides, and attempts to make the surface\nas accessible and extensible as possible.\n\nYour design reviewer is not only evaluating your API, but also checking to\nensure that your API is consistent with Google's existing corpus of APIs. Many\ncustomers use multiple APIs, and therefore it is important that our conventions\nand naming choices line up with customer expectations.\n\n## What should I expect?\n\n### How long does the review process take?\n\nReviewers make an effort to keep up with their assigned reviews and offer\nfeedback frequently, so as not to cause unnecessary delay, but it's generally\nbest to begin the review process early in case there are delays.\n\nThe design review process varies based on the size and complexity of the\nunderlying API surface:\n\n- Incremental changes to existing APIs generally take a few days.\n- Small APIs usually take around a week.\n- Entirely new APIs with large surfaces tend to take no less than a week. In\n  cases with extraordinarily large surfaces (e.g., Cloud AutoML), reviews may\n  take a month or more to go through design review.\n\n### How do reviewers approach my API?\n\nAPI reviewers seek to approach your API the same way that your users will, by\nfocusing primarily on the API surface and its user-facing documentation. In an\nideal world, your API reviewer will ask the types of design questions that\nusers will ask (and nudge the API toward raising fewer of those questions in\nthe first place).\n\n### What is precedent?\n\nIn general, we want Google APIs to be as consistent as possible. Once customers\nlearn their first Google API, it should be easier to learn the second (and then\nthe third, and so on) because we are using the same patterns consistently.\n\nWe refer to **precedent** to mean decisions that have already been made by\nprevious APIs, which generally should be binding upon newer APIs in similar\nsituations. The most common example of this is naming: we have a list of\n[standard fields][] that dictate how we use common terms like `name`,\n`create_time`, and so forth, and which also dictates that we always attach _the\nsame_ name to the same concept.\n\nPrecedent also applies to _patterns_. All APIs should implement pagination the\nsame way. Ditto for long-running operations, import and export, and so on. Once\na pattern has been established, we seek to implement that pattern the same way\nwherever it is germane.\n\n## What should I do?\n\n### ...if I have a launch on a tight deadline?\n\nThe best thing that you can do is to engage design review as early as possible.\nAdditionally, make your reviewers aware of your timeline so that they are\naware, and can endeavor to provide you the best possible service. We _want_ you\nto make your deadline if at all possible.\n\nFor time-sensitive _alpha_ launches, an API **may** launch without receiving\ndesign review approval. Such launches **must** be limited to a known set of\nusers. In this case, the reviewers will provide notes for the API team to take\nunder consideration for subsequent stages.\n\n**Warning:** Launching an API in alpha with an incomplete design review **does\nnot** enshrine that API's decisions. Design review will be required to promote\nthe API to beta, and API reviewers will block your beta launch if there are\nissues.\n\nFor launch stages after alpha, the API design review is mandatory due to its\nimpact on user experience across the board. Your team's inconsistencies affect\nmore than just your team.\n\nIn some cases, there is a difficult choice to be made between product\nexcellence and either engineering effort or deadlines. These are difficult\nbusiness decisions and we understand that they are sometimes necessary;\nhowever, a director or VP must make an explicit choice to put these other\nconcerns ahead of product excellence when choosing to bypass design review or\ndisregard reviewers' feedback.\n\n### ...to make my review go faster?\n\nA few tips:\n\n- Begin API review as early as possible, and follow up frequently.\n- Run the [API linter][] beforehand. (If you are disabling the linter at any\n  point, explain why. Reviewers often find that the linter is disabled because\n  it did its job.)\n- Ensure that every message, RPC, and field is _usefully_ commented. Comments\n  should be in valid American English and say something meaningful.\n- If your API reviewer asks you to explain something, add the explanation _in\n  the proto comments_, rather than the code review conversation. This will very\n  often save you a round trip.\n\n### ...if one of my API reviewers is unresponsive?\n\nReach out to the reviewer on Hangouts. If that fails, reach out to the other\nreviewer, who will coordinate accordingly. If that fails also, escalate\naccording to [AIP-1][].\n\n### ...if I have a design question?\n\nThe first places to look at the [API style guide][], the [AIP index][], and\nother public APIs within Google. Other public APIs are particularly valuable;\nit is common that someone has encountered a situation that is germane to your\nquestion.\n\n### ...if I have a question not covered there?\n\nReach out to api-design@google.com with your question.\n\nThis generally works best when you are seeking guidance on a specific question\nrelated to API design, and when you clearly explain your use case and provide\nexamples.\n\n**Note:** The membership of this list comprises almost exclusively volunteers,\nwho spend the majority of their time doing something else. We do our best to be\nresponsive, but please be patient with us.\n\n### ...if a question is complex and languishing in a CL?\n\nWhile the code review interface is the best way to resolve questions when\npractical, sometimes there are issues that are sufficiently complicated that\nworking them out in the code review tool is not feasible. In this situation,\nreach out to your reviewers and ask to schedule a meeting. In general, most\nissues can be discussed in 30 minutes.\n\nWhen this happens, make sure that someone documents what is discussed in the\nCL, so that the history is preserved.\n\n### ...if my API needs to violate a standard?\n\nClearly document (using an internal comment in the proto) that you are\nviolating an API design guideline and your rationale for doing so. This comment\n**must** be prefixed with `aip.dev/not-precedent`.\n\nIn general, your rationale for the design guideline violation **should** be in\naccordance with one of the enumerated reasons listed in [AIP-200][]. If it is\nnot, work together with your API reviewer to determine the right thing to do.\n\n### ...if a reviewer is bringing up a previously-settled issue?\n\nIf you have a different reviewer from your API's previous stages, this might\nhappen. In general, the best approach is simply to reference the code review\nwhere the issue was decided. Reviewers want to avoid causing you churn, and\ntherefore usually give deference to previous reviews. This is usually\nsufficient to resolve the question promptly.\n\nOccasionally, the reviewer may believe that the previous reviewer made a\nsignificant mistake, and that correcting it is important. In this case, you and\nyour reviewer should work together to determine the best course of action.\n\n### ...if the team and the reviewers strongly disagree?\n\nEscalate according to [AIP-1][].\n\n## Does my PA or team have any particular guidelines?\n\nThe Cloud PA has specific guidelines to ensure additional uniformity across\nCloud, and Cloud APIs have their own reviewer pool. Other teams may adopt\nsimilar (but not necessarily identical) rules and systems. Some teams that\nproduce multiple APIs (for example, machine learning) may also have guidelines\nthat apply to that group of APIs.\n\nIn all cases, we endeavor to make these guidelines available as AIPs; the\nhigher AIP numbers are reserved for specific PA and team use (see [AIP-2][]),\nand these AIPs are listed in the [AIP index][].\n\n[aip-1]: ./0001.md\n[aip-2]: ./0002.md\n[aip-200]: ./0200.md\n[aip index]: /\n[api linter]: https://github.com/googleapis/api-linter\n[api style guide]: https://cloud.google.com/apis/design/\n[standard fields]: https://cloud.google.com/apis/design/standard_fields\n"}