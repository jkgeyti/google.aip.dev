{"text": "---\nid: 211\nstate: approved\ncreated: 2021-02-24\nplacement:\n  category: design-patterns\n  order: 115\n---\n\n# Authorization checks\n\nThe majority of operations, whether reads or writes, require authorization:\npermission to do the thing the user is asking to do. Additionally, it is\nimportant to be careful how much information is provided to _unauthorized_\nusers, since leaking information can be a security concern.\n\n## Guidance\n\nServices **must** check authorization before validating any request, to ensure\nboth a secure API surface and a consistent user experience. An operation\n**may** require multiple permissions or preconditions in order to grant\nauthorization.\n\nIf a request can not pass the authorization check for any reason, the service\n**must** error with `PERMISSION_DENIED`, and the corresponding error message\n**should** look like: \"Permission `{p}` denied on resource `{r}` (or it might\nnot exist).\" This avoids leaking resource existence.\n\nIf it is not possible to determine authorization for a resource because the\nresource does not exist, the service **should** check authorization to read\nchildren on the parent resource, and return `NOT_FOUND` if the authorization\ncheck passes.\n\n### Multiple operations\n\nA service could encounter a situation where it has two different operations\nwith two different permissions, either of which would reveal the existence of a\nresource if called, but a user only has permission to call one of them.\n\nIn this situation, the service **should** still only check for authorization\napplicable to the operation being called, and **should not** try to \"help out\"\nby checking for related authorization that would provide permission to reveal\nexistence, because such algorithms are complicated to implement correctly and\nprone to accidental leaks.\n\nFor example, posit a scenario where:\n\n- A resource exists within a given collection that a user is unable to read.\n- The user _does_ have the ability to create other resources, and the\n  collection uses user-specified IDs (meaning that a failure because of a\n  duplicate ID would reveal existence).\n\nIn this situation, the get or create methods **should** still only check\n_their_ permissions when determining what error to return, and not one\nanother's.\n\n## Rationale\n\n[RFC 7231 \u00a76.5.3][] states that services are permitted to use `404 Not Found`\nin lieu of `403 Forbidden` in situations where the service does not want to\ndivulge existence, whereas this AIP argues for the use of `PERMISSION_DENIED`\n(which corresponds to `403 Forbidden` in HTTP) instead. We take this position\nfor the following reasons:\n\n- The practice of \"getting `404 Not Found` until you have enough permission to\n  get `403 Forbidden`\" is counter-intuitive and increases the difficulty of\n  troubleshooting.\n  - A service _could_ ameliorate this by sending information about missing\n    permissions while still using the `404 Not Found` status code, but this\n    constitutes a mixed message.\n- While `403 Forbidden` is essentially always an error requiring manual action,\n  `404 Not Found` is often a valid response that the application can handle\n  (e.g. \"get or create\"); overloading it for permission errors deprives\n  applications of this benefit.\n- RFC 7231 \u00a76.5.4 states that `404 Not Found` results are cacheable, but\n  permission errors are not generally cacheable. Sending explicit cache\n  controls on a conditional basis could ameliorate this, but would defeat the\n  purpose.\n- The guidance here is more consistent with most other real-world authorization\n  systems.\n\n[rfc 7231 \u00a76.5.3]: https://tools.ietf.org/html/rfc7231#section-6.5.3\n\n## Changelog\n\n- **2021-05-11:** Added a more detailed \"Rationale\" section.\n"}