{"text": "---\nid: 160\nstate: approved\ncreated: 2020-02-24\nplacement:\n  category: design-patterns\n  order: 80\n---\n\n# Filtering\n\nOften, when listing resources (using a list method as defined in [AIP-132][] or\nsomething reasonably similar), it is desirable to filter over the collection\nand only return results that the user is interested in.\n\nIt is tempting to define a structure to handle the precise filtering needs for\neach API. However, filtering requirements evolve frequently, and therefore it\nis prudent to use a string field with a structured syntax accessible to a\nnon-technical audience. This allows updates to be able to be made\ntransparently, without waiting for UI or client updates.\n\n**Note:** Because list filters are intended for a potentially non-technical\naudience, they sometimes borrow from patterns of colloquial speech rather than\ncommon patterns found in code.\n\n## Guidance\n\nAPIs **may** provide filtering to users on `List` methods (or similar methods\nto query a collection, such as `Search`). If they choose to do so, they\n**should** follow the common specification for filters discussed here. The\nsyntax is formally defined in the [EBNF grammar][].\n\nWhen employing filtering, a request message **should** have exactly one\nfiltering field, `string filter`. Filtering of related objects is handled\nthrough [traversal](#traversal-operator) or [functions](#functions).\n\n**Note:** List Filters have fuzzy matching characteristics with support for\nresult ranking and scoring. For developers interested in deterministic\nevaluation of list filters, see [CEL][].\n\n### Literals\n\nA bare literal value (examples: \"42\", \"Hugo\") is a value to be matched against.\nLiterals appearing alone (with no specified field) **should** usually be\nmatched anywhere it may appear in an object's field values.\n\nHowever, a service **may** choose to only consider certain fields; if so, it\n**must** document which fields it considers. A service **may** include new\nfields over time, but **should** do so judiciously and consider impact on\nexisting users.\n\n**Note:** Literals separated by whitespace are considered to have a fuzzy\nvariant of `AND`. Therefore, `Victor Hugo` is roughly equivalent to\n`Victor AND Hugo`.\n\n### Logical Operators\n\nFiltering implementations **should** provide the binary operators:\n\n| Operator | Example       | Meaning                                |\n| -------- | ------------- | -------------------------------------- |\n| `AND`    | `a AND b`     | True if `a` and `b` are true.          |\n| `OR`     | `a OR b OR c` | True if any of `a`, `b`, `c` are true. |\n\n**Note:** To match common patterns of speech, the `OR` operator has higher\nprecedence than `AND`, unlike what is found in most programming languages. The\nexpression `a AND b OR c` evaluates: `a AND (b OR c)`. API documentation and\nexamples **should** encourage the use of explicit parentheses to avoid\nconfusion, but **should not** require explicit parentheses.\n\n### Negation Operators\n\nFiltering implementations **should** provide the unary operators `NOT` and `-`.\nThese are used interchangeably, and a service that supports negation **must**\nsupport both formats.\n\n| Operator | Example | Meaning                  |\n| -------- | ------- | ------------------------ |\n| `NOT`    | `NOT a` | True if `a` is not true. |\n| `-`      | `-a`    | True if `a` is not true. |\n\n### Comparison Operators\n\nFiltering implementations **should** provide the binary comparison operators\n`=`, `!=`, `<`, `>`, `<=`, and `>=` for string, numeric, timestamp, and\nduration fields (but **should not** provide them for booleans or enums).\n\n| Operator | Example      | Meaning                                         |\n| -------- | ------------ | ----------------------------------------------- |\n| `=`      | `a = true`   | True if `a` is true.                            |\n| `!=`     | `a != 42`    | True unless `a` equals 42.                      |\n| `<`      | `a < 42`     | True if `a` is a numeric value below 42.        |\n| `>`      | `a > \"foo\"`  | True if `a` is lexically ordered after \"foo\".   |\n| `<=`     | `a <= \"foo\"` | True if `a` is \"foo\" or lexically before it.    |\n| `>=`     | `a >= 42`    | True if `a` is a numeric value of 42 or higher. |\n\n**Note:** Unlike in most programming languages, field names **must** appear on\nthe left-hand side of a comparison operator; the right-hand side only accepts\nliterals and logical operators.\n\nBecause filters are accepted as query strings, type conversion takes place to\ntranslate the string to the appropriate strongly-typed value:\n\n- Enums expect the enum's string representation (case-sensitive).\n- Booleans expect `true` and `false` literal values.\n- Numbers expect the standard integer or float representations. For floats,\n  exponents are supported (e.g. `2.997e9`).\n- [Durations][] expect a numeric representation followed by an `s` suffix (for\n  seconds). Examples: `20s`, `1.2s`.\n- [Timestamps][] expect an [RFC-3339][] formatted string (e.g.\n  `2012-04-21T11:30:00-04:00`). UTC offsets are supported.\n\n**Warning:** The identifiers `true`, `false`, and `null` only carry intrinsic\nmeaning when used in the context of a typed field reference.\n\nAdditionally, when comparing strings for equality, services **should** support\nwildcards using the `*` character; for example, `a = \"*.foo\"` is true if `a`\n_ends with_ \".foo\".\n\n### Traversal operator\n\nFiltering implementations **should** provide the `.` operator, which indicates\ntraversal through a message, map, or struct.\n\n| Example         | Meaning                                               |\n| --------------- | ----------------------------------------------------- |\n| `a.b = true`    | True if `a` has a boolean `b` field that is true.     |\n| `a.b > 42`      | True if `a` has a numeric `b` field that is above 42. |\n| `a.b.c = \"foo\"` | True if `a.b` has a string `c` field that is \"foo\".   |\n\nTraversal **must** be written using the field names from the resource. If a\nservice wishes to support \"implicit fields\" of some kind, they **must** do so\nthrough well-documented [functions](#functions). A service **may** specify a\nsubset of fields that are supported for traversal.\n\nIf a user attempts to traverse to a field that is not defined on the message,\nthe service **should** return an error with `INVALID_ARGUMENT`. A service\n**may** permit traversal to undefined keys on maps and structs, and **should**\ndocument how it behaves in this situation.\n\n**Important:** The `.` operator **must not** be used to traverse through a\nrepeated field or list, except for specific use with the `:` operator.\n\n### Has Operator\n\nFiltering implementations **must** provide the `:` operator, which means \"has\".\nIt is usable with collections (repeated fields or maps) as well as messages,\nand behaves slightly differently in each case.\n\nRepeated fields query to see if the repeated structure contains a matching\nelement:\n\n| Example    | Meaning                                                     |\n| ---------- | ----------------------------------------------------------- |\n| `r:42`     | True if `r` contains 42.                                    |\n| `r.foo:42` | True if `r` contains an element `e` such that `e.foo = 42`. |\n\n**Important:** Filters can not query a _specific_ element on a repeated field\nfor a value. For example, `e.0.foo = 42` and `e[0].foo = 42` are **not** valid\nfilters.\n\nMaps, structs, messages can query either for the presence of a field in the map\nor a specific value:\n\n| Example    | Meaning                             |\n| ---------- | ----------------------------------- |\n| `m:foo`    | True if `m` contains the key \"foo\". |\n| `m.foo:*`  | True if `m` contains the key \"foo\". |\n| `m.foo:42` | True if `m.foo` is 42.              |\n\nThere are two slight distinctions when parsing messages:\n\n- When traversing messages, a field is only considered to be present if it has\n  a non-default value.\n- When traversing messages, field names are snake case, although\n  implementations **may** choose to support automatic conversion between camel\n  case and snake case.\n\n### Functions\n\nThe filtering language supports a function call syntax in order to support\nAPI-specific extensions. An API **may** define a function using the\n`call(arg...)` syntax, and **must** document any specific functions it\nsupports.\n\n### Limitations\n\nA service **may** specify further structure or limitations for filter queries,\nabove what is defined here. For example, a service may support the logical\noperators but only permit a certain number of them (to avoid \"queries of death\"\nor other performance concerns).\n\nFurther structure or limitations **must** be clearly documented, **must not**\nviolate requirements set forth in this document, and a non-compliant filter\nquery **must** error with `INVALID_ARGUMENT`.\n\n<!-- prettier-ignore-start -->\n[aip-132]: ./0132.md\n[cel]: https://github.com/google/cel-spec\n[cel-cpp]: https://github.com/google/cel-cpp\n[cel-go]: https://github.com/google/cel-go\n[durations]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/duration.proto\n[ebnf grammar]: /assets/misc/ebnf-filtering.txt\n[rfc-3339]: https://tools.ietf.org/html/rfc3339\n[timestamps]: https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/timestamp.proto\n<!-- prettier-ignore-end -->\n"}