{"text":"---\nid: 236\nstate: approved\ncreated: 2023-03-30\nupdated: 2023-03-30\nplacement:\n  category: resource-design\n  order: 240\n---\n\n# Policy preview\n\nA policy is a resource that provides rules that admit or deny access to other\nresources. Generally, the outcome of a policy can be evaluated to a specific set\nof outcomes.\n\nChanges to policies without proper validation may have unintended consequences\nthat can severely impact a customerâ€™s overall infrastructure setup. To safely\nupdate resources, it is beneficial to test these changes via policy rollout\nAPIs.\n\nPreview is a rollout safety mechanism for policy resources, which gives the\ncustomer the ability to validate the effect of their proposed changes against\nproduction traffic prior to the changes going live. The result of the policy\nevaluation against traffic is logged in order to give the customer the data\nrequired to test the correctness of the change.\n\nFirewall policies exemplify a case that is suitable for previewing. A new\nconfiguration can be evaluated against traffic to observe which IPs would be\nallowed or denied. This gives the customer the data to guide a decision on\nwhether to promote the proposed changes to live.\n\nThe expected flow for previewing a policy is as follows:\n\n1. The user creates an experiment containing a new policy configuration\n   intended to replace the live policy.\n2. The user uses the \"startPreview\" method to start generating logs which compare\n   the live and experiment policy evaluations against live traffic.\n3. The user inspects the logs to determine whether the experiment has the\n   intended result.\n4. The user uses the \"commit\" method to promote the experiment to live.\n\n## Guidance\n\n### Non-goals\n\nThis proposal is for a safety mechanism for policy rollouts only. Safe rollouts\nfor non-policy resources are not in scope.\n\n### Experiments\n\nA new configuration of a policy to be previewed is stored as a nested collection\nunder the policy. These nested collections are known as experiments.\n\nA hypothetical policy resource called, `Policy`, is used throughout. It has the\nfollowing resource name pattern:\n\n`projects/{project}/locations/{location}/policies/{policy}`\n\nThe experimental versions of the resource used for previewing or other safe\nrollout practices are represented as a nested collection under `Policy` using a\nnew resource type. The resource type **must** follow the naming convention\n*RegularResourceType*`Experiment`.\n\nThe following pattern is used for the experiment collection:\n\n`projects/{project}/locations/{location}/policies/{policy}/experiments/{experiment}`\n\nA proto used to represent an experiment **must** contain the following:\n\n  1. The required top-level fields for a resource, like `name` and `etag`\n  2. The policy message that is being tested itself\n  3. The field, `preview_metadata`, which contains metadata specific to\n     previewing the experiment of a specific resource type.\n\n```proto\nmessage PolicyExperiment {\n\n  // google.api.resource, name, and other annotations and fields\n\n  // The policy experiment. This Policy will be used to preview the effects of\n  // the change but will not affect live traffic.\n  Policy policy = 2;\n\n  // The metadata associated with this policy experiment.\n  PolicyPreviewMetadata preview_metadata = 3\n      [(google.api.field_behavior) = OUTPUT_ONLY];\n\n  // Allows clients to store small amounts of arbitrary data.\n  map<string, string> annotations = 4;\n}\n```\n\n- The experiment proto **must** have a top-level field with the same type as the\n  live policy.\n  - It **must** be named as the live resource type. For example, if the\n    experiment is for FirewallPolicy, then this field **must** be named\n    `firewall_policy`.\n  - The name inside the embedded `policy` message **must** be the name of the\n    live policy.\n- When the user is ready to promote an experiment, they **must** copy the\n  `policy` message into the live policy and delete the experiment. This can be\n  done manually or via a \"commit\" custom method.\n- A product **may** support multiple experiments concurrently being previewed\n  for a single live policy.\n  - Each experiment must generate logs having each entry preceded by log_prefix\n    so that the user can compare the results of the experiment with the behavior\n    of the live policy.\n  - The number of experimental configurations for a given live policy **may** be\n    capped at a certain number and the cap **must** be documented.\n- Cascading deletes **must** occur: if the live policy is deleted, all\n  experiments **must** also be deleted.\n- `map<string,string>` [annotations][aip-128-annotations] **must** allow clients\n  to store small amounts of arbitrary data.\n\n### Metadata\n\n`preview_metadata` tracks all metadata of previewing the experiment. The\nmessages **must** follow the convention: *RegularResourceType*`PreviewMetadata`.\nThis is so the proto can be defined uniquely for each resource type in the\nsame service with experiments.\n\n```proto\nmessage PolicyPreviewMetadata {\n  // Possible values of the state of previewing the experiment.\n  enum State {\n    // Default value. This value is unused.\n    STATE_UNDEFINED = 0;\n\n    // The experiment is actively previewing.\n    ACTIVE = 1;\n\n    // The previewing of the experiment has been stopped.\n    SUSPENDED = 2;\n  }\n\n  // The state of previewing the experiment.\n  State state = 1;\n\n  // An identifying string common to all logs generated when previewing the\n  // experiment. Searching all logs for this string will isolate the results.\n  string log_prefix = 2;\n\n  // The most recent time at which this experiment started previewing.\n  google.protobuf.Timestamp start_time = 3;\n\n  // The most recent time at which this experiment stopped previewing.\n  google.protobuf.Timestamp stop_time = 4;\n}\n```\n\n- `PolicyPreviewMetadata` **must** have the fields defined in the proto above.\n  - It **may** have additional fields if the service or resource requires it.\n- When an experiment is first previewed, `preview_metadata` **must** be\n  absent.\n  - It is present on the experiment once the \"startPreview\" method is used.\n- All `preview_metadata` fields **must** be output only.\n- `state` changes between `ACTIVE` and `SUSPENDED` when previewing is started\n  or stopped. This happens when the \"startPreview\" or \"stopPreview custom methods\n  are invoked, respectively.\n- The first time the \"startPreview\" custom method is used, the system **must**\n  create `preview_metadata` and do the following:\n  - It **must** set the `state` to `ACTIVE`\n  - It **must** populate `start_time` with the current time.\n    - `start_time` **must** be updated every time `state` is changed to\n      `ACTIVE`.\n  - It **must** set a system generated `log_prefix` string, which is a\n    predefined constant hard coded by the system developers.\n  - The same value is used for previewing experiments for the given resource\n    type. For example, \"FirewallPolicyPreviewLog\" for FirewallPolicy.\n- When the \"stopPreview\" custom method is used, the system **must** do the\n  following:\n  - It **must** set the `state` to `SUSPENDED`\n  - It **must** populate the `stop_time` with the current time.\n\n### Methods\n\n#### create\n\n- The resource **must** be created using long-running\n  [Create][aip-133-long-running] and\n  `google.longrunning.operation_info.response_type` **must** be\n  `PolicyExperiment`.\n- Creating a new experiment to preview **must** support the following use\ncases:\n  - Preview a new policy.\n  - Preview an update to an already live policy.\n  - Preview a deletion of a current policy.\n- For the update and delete use cases, the `policy` field in the experiment\n  **must** have the full payload of the live policy copied into it, including\n  the name.\n  - The user **must** set the rules to the new intended state to preview an\n    update.\n  - The user **must** set set the rules to represent a no-op to preview a\n    delete.\n- To preview a new policy, the system must do the following:\n  - If the system does not support a nested collection without a live policy,\n    the user **must** create a live policy and set the rules to represent a\n    no-op. For example, the rules of a no-op policy **may** be empty.\n    - An experiment is created as a child of the no-op policy.\n- If the system supports previewing multiple experiments for a live policy,\n  calling \"create\" more than once **must** create multiple experiments.\n\n#### update\n\n- The resource **must** be updated using long-running\n  [Update][aip-134-long-running] and\n  `google.longrunning.operation_info.response_type` **must** be\n  `PolicyExperiment`.\n- The name inside `policy` **must not** change but the other fields can in\n  order to change the experiment being previewed because this `policy` is\n  intended to replace the live policy, and the name of the live policy\n  **must not** change.\n- The system **must** set the `state` to `SUSPENDED` if the `state` was `ACTIVE`\n  at the time of an update.\n  - This is so the user can easily distinguish between different versions of\n    the experiment being previewed.\n\n#### get\n- The standard method, [Get][aip-131], **must** be included for\n  `PolicyExperiment` resource types.\n\n#### list\n\n- The standard method, [List][aip-132], **must** be included for\n  `PolicyExperiment` resource types.\n- Filtering on `PolicyPreviewMetadata` indicates which experiments are actively\n  previewed.\n  - For example, the following filter string returns a List response with\n    experiments being previewed: preview_metadata.state = ACTIVE.\n\n#### delete\n\n- The resource **must** be deleted using long-running\n  [Delete][aip-135-long-running] and\n  `google.longrunning.operation_info.response_type` **must** be\n  `PolicyExperiment`.\n\n#### startPreview\n\n```proto\n// Starts previewing a PolicyExperiment. This triggers the system to start\n// generating logs to evaluate the PolicyExperiment.\nrpc StartPreviewPolicyExperiment(StartPreviewPolicyExperimentRequest)\n    returns (google.longrunning.Operation) {\n  option (google.api.http) = {\n    post: \"/v1/{name=policies/*/experiments/*}:startPreview\"\n    body: \"*\"\n  };\n  option (google.longrunning.operation_info) = {\n    response_type: \"PolicyExperiment\"\n    metadata_type: \"StartPreviewPolicyExperimentMetadata\"\n  };\n}\n\n// The request message for the startPreview custom method.\nmessage StartPreviewPolicyExperimentRequest {\n  // The name of the PolicyExperiment.\n  string name = 1;\n}\n```\n\n- This custom method is required.\n- `google.longrunning.Operation.metadata_type` **must** follow guidance on\n  [Long-running operations][aip-151]\n- This method **must** trigger the system to start generating logs to preview\n  the experiment.\n- Whenever the method is called successfully, the system **must** set the\n  following values in the `PolicyPreviewMetadata`:\n  - `log_prefix` to the predefined constant.\n  - `start_time` to the current time\n  - `state` to `ACTIVE`.\n- If the method is called on an experiment with the rules representing a no-op,\n  then the system **must** preview the deletion of the live policy.\n\n#### stopPreview\n\n```proto\n// Stops previewing a PolicyExperiment. This triggers the system to stop\n// generating logs to evaluate the PolicyExperiment.\nrpc StopPreviewPolicyExperiment(StopPreviewPolicyExperimentRequest)\n    returns (google.longrunning.Operation) {\n  option (google.api.http) = {\n    post: \"/v1/{name=policies/*/experiments/*}:stopPreview\"\n    body: \"*\"\n  };\n  option (google.longrunning.operation_info) = {\n    response_type: \"PolicyExperiment\"\n    metadata_type: \"StopPreviewPolicyExperimentMetadata\"\n  };\n}\n\n// The request message for the stopPreview custom method.\nmessage StopPreviewPolicyExperimentRequest {\n  // The name of the PolicyExperiment.\n  string name = 1;\n}\n```\n\n- This custom method is required.\n- `google.longrunning.Operation.metadata_type` **must** follow guidance on\n  [Long-running operations][aip-151]\n- This method **must** trigger the system to stop generating logs to preview the\n  experiment.\n- Whenever the method is called successfully, the system **must** set the\n  following values in the `PolicyPreviewMetadata`:\n  - `stop_time` to the current time\n  - `state` to `SUSPENDED`\n\n#### commit\n\nThe resource **may** expose a new custom method called \"commit\" to promote an\nexperiment. The system copies `policy` from the experiment into the live policy\nand then deletes the experiment.\n\nDeclarative clients **may** manually copy fields from an experiment into the\nlive policy and then delete the experiment rather than calling \"commit\" if\npreferable.\n\n```proto\n// Commits a PolicyExperiment. This copies the PolicyExperiment's policy message\n// to the live policy then deletes the PolicyExperiment.\nrpc CommitPolicyExperiment(CommitPolicyExperimentRequest)\n    returns (google.longrunning.Operation) {\n  option (google.api.http) = {\n    post: \"/v1/{name=policies/*/experiments/*}:commit\"\n    body: \"*\"\n  };\n  option (google.longrunning.operation_info) = {\n    response_type: \"google.protobuf.Empty\"\n    metadata_type: \"CommitPolicyExperimentMetadata\"\n  };\n}\n\n// The request message for the commit custom method.\nmessage CommitPolicyExperimentRequest {\n  string name = 1;\n  string etag = 2;\n  string parent_etag = 3;\n}\n```\n\n- `google.longrunning.Operation.metadata_type` **must** follow guidance on\n  [Long-running operations][aip-151]\n- The method **must** atomically copy `policy` from the experiment into the live\n  policy, and then delete the experiment.\n- If any experiment fails \"commit\", previewing it **must not** stop, and the\n  live policy **must not** be updated.\n- The method can be called on an experiment in any state.\n- The `etag` **must** match that of the experiment in order for commit to be\n  successful. This is so the user does not commit an unintended version of the\n  experiment.\n  - If no `etag` is provided, the API **must not** succeed to prevent the user\n    from unintentionally committing a different version of the experiment as\n    intended.\n  - A `parent_etag` **may** be provided to guarantee that the experiment\n    overwrites a specific version of the live policy.\n- The method is not idempotent and calling it twice on the same experiment\n  **must** return a 404 NOT_FOUND as the experiment is deleted as part of the\n  first call.\n\n### Changes to live policy API methods\n\n#### delete\n\n- A delete of the live policy **must** delete all experiments.\n- To maintain the experiments while negating the effect of the live policy, the\n  live policy **must** be changed to a no-op policy instead of using this\n  method.\n\n### Logging\n\nLogging is crucial for the user to evaluate whether an experiment should be\npromoted to live.\n\nLogs **must** contain the results of the evaluated experiment, the `etag`\nassociated with that experiment alongside that of the live policy, and be\npreceded by the value of `log_prefix`.\n  - The `etag` fields help the user identify which\n    configurations of the live and experiment are evaluated in the log.\n  - `log_prefix` helps the user separate logs specifically generated for\n    previewing the experiment from other use cases.\n\nOverall, these logs help the user make a decision about whether to promote the\nexperiment to live.\n\n## Changelog\n\n- **2023-04-27:** Methods for start and stop renamed. State to enum. Annotations\n  added.\n- **2023-03-30:** Initial AIP written.\n\n[aip-128-annotations]: https://aip.dev/128#annotations\n[aip-131]: https://aip.dev/131\n[aip-132]: https://aip.dev/132\n[aip-133-long-running]: https://aip.dev/133#long-running-create\n[aip-134-long-running]: https://aip.dev/134#long-running-update\n[aip-135-long-running]: https://aip.dev/135#long-running-delete\n[aip-151]: https://google.aip.dev/151\n"}
