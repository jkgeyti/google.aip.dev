{"text":"---\nid: 180\nstate: approved\ncreated: 2019-07-23\nplacement:\n  category: compatibility\n  order: 10\n---\n\n# Backwards compatibility\n\nAPIs are fundamentally contracts with users, and users often write code against\nAPIs that is then launched into a production service with the expectation that\nit continues to work (unless the API has a [stability level][aip-181] that\nindicates otherwise). Therefore, it is important to understand what constitutes\na backwards compatible change and what constitutes a backwards incompatible\nchange.\n\n## Guidance\n\nExisting client code **must not** be broken by a service updating to a new\nminor or patch release. Old clients **must** be able to work against newer\nservers (with the same major version number).\n\n**Important:** It is not always clear whether a change is compatible or not.\nThe guidance here **should** be treated as indicative, rather than as a\ncomprehensive list of every possible change.\n\nThere are three distinct types of compatibility to consider:\n\n1. Source compatibility: Code written against a previous version **must**\n   compile against a newer version, and successfully run with a newer version\n   of the client library.\n2. Wire compatibility: Code written against a previous version **must** be able\n   to communicate correctly with a newer server. In other words, not only are\n   inputs and outputs compatible, but the serialization and deserialization\n   expectations continue to match.\n3. Semantic compatibility: Code written against a previous version **must**\n   continue to receive what most reasonable developers would expect. (This can\n   be tricky in practice, however, and sometimes determining what users will\n   expect can involve a judgment call.)\n\n**Note:** In general, the specific guidance here assumes use of protocol\nbuffers and JSON as transport formats. Other transport formats may have\nslightly different rules.\n\n**Note:** This guidance assumes that APIs are intended to be called from a\nrange of consumers, written in multiple languages and with no control over\nhow and when consumers update. Any API which has a more limited scope (for\nexample, an API which is only called by client code written by the same team\nas the API producer, or deployed in a way which can enforce updates) should\ncarefully consider its own compatibility requirements.\n\n### Adding components\n\nIn general, new components (interfaces, methods, messages, fields, enums, or\nenum values) **may** be added to existing APIs in the same major version.\n\nHowever, keep the following guidelines in mind when doing this:\n\n- Code written against the previous surface (and thus is unaware of the new\n  components) **must** continue to be treated the same way as before.\n  - New required fields **must not** be added to existing request messages or\n    resources.\n  - Any field being populated by clients **must** have a default behavior\n    matching the behavior before the field was introduced.\n  - Any field previously populated by the server **must** continue to be\n    populated, even if it introduces redundancy.\n- For enum values specifically, be aware that it is possible that user code\n  does not handle new values gracefully.\n  - Enum values **may** be freely added to enums which are only used in request\n    messages.\n  - Enums that are used in response messages or resources and which are\n    expected to receive new values **should** document this. Enum values still\n    **may** be added in this situation; however, appropriate caution **should**\n    be used.\n\n**Note:** It is possible when adding a component closely related to an existing\ncomponent (for example, `string foo_value` when `string foo` already exists) to\nenter a situation where generated code will conflict. Service owners **should**\nbe aware of subtleties in the tooling they or their users are likely to use\n(and tool authors **should** endeavor to avoid such subtleties if possible).\n\n### Removing or renaming components\n\nExisting components (interfaces, methods, messages, fields, enums, or enum\nvalues) **must not** be removed from existing APIs in the same major version.\nRemoving a component is a backwards incompatible change.\n\n**Important:** Renaming a component is semantically equivalent to \"remove and\nadd\". In cases where these sorts of changes are desirable, a service **may**\nadd the new component, but **must not** remove the existing one. In situations\nwhere this can allow users to specify conflicting values for the same semantic\nidea, the behavior **must** be clearly specified.\n\n### Moving components between files\n\nExisting components **must not** be moved between files.\n\nMoving a component from one proto file to another within the same package is\nwire compatible, however, the code generated for languages like C++ or Python\nwill result in breaking change since `import` and `#include` will no longer\npoint to the correct code location.\n\n### Moving into oneofs\n\nExisting fields **must not** be moved into or out of a oneof. This is a\nbackwards-incompatible change in the Go protobuf stubs.\n\n### Changing the type of fields\n\nExisting fields and messages **must not** have their type changed, even if the\nnew type is wire-compatible, because type changes alter generated code in a\nbreaking way.\n\n### Changing resource names\n\nA resource **must not** change its [name][aip-122].\n\nUnlike most breaking changes, this affects major versions as well: in order for\na client to expect to use v2.0 access a resource that was created in v1.0 or\nvice versa, the same resource name **must** be used in both versions.\n\nMore subtly, the set of valid resource names **should not** change either, for\nthe following reasons:\n\n- If resource name formats become more restrictive, a request that would\n  previously have succeeded will now fail.\n- If resource name formats become less restrictive than previously documented,\n  then code making assumptions based on the previous documentation could break.\n  Users are very likely to store resource names elsewhere, in ways that may be\n  sensitive to the set of permitted characters and the length of the name.\n  Alternatively, users might perform their own resource name validation to\n  follow the documentation.\n  - For example, Amazon gave customers [a lot of warning][ec2] and had a\n    migration period when they started allowing longer EC2 resource IDs.\n\n### Semantic changes\n\nCode will often depend on API behavior and semantics, _even when such behavior\nis not explicitly supported or documented_. Therefore, APIs **must not** change\nvisible behavior or semantics in ways that are likely to break reasonable user\ncode, as such changes will be seen as breaking by those users.\n\n**Note:** This does involve some level of judgment; it is not always clear\nwhether a proposed change is likely to break users, and an expansive reading of\nthis guidance could ostensibly prevent _any_ change (which is not the intent).\n\n#### Default values must not change\n\nDefault values are the values set by servers for resources when they are not\nspecified by the client. This section only applies to static default values within\nfields on resources and does not apply to dynamic defaults such as the default IP\naddress of a resource.\n\nChanging the default value is considered breaking and **must not** be done. The\ndefault behavior for a resource is determined by its default values, and this\n**must not** change across minor versions.\n\nFor example:\n\n```proto\nmessage Book {\n    // google.api.resource and other annotations and fields\n\n    // The genre of the book\n    // If this is not set when the book is created, the field will be given a value of FICTION.\n    enum Genre {\n      UNSPECIFIED = 0;\n      FICTION = 1;\n      NONFICTION = 2;\n    }\n}\n```\n\nChanging to:\n\n```proto\nmessage Book {\n    // google.api.resource and other annotations and fields\n\n    // The genre of the book\n    // If this is not set when the book is created, the field will be given a value of NONFICTION.\n    enum Genre {\n      UNSPECIFIED = 0;\n      FICTION = 1;\n      NONFICTION = 2;\n    }\n}\n```\n\nwould constitute a breaking change.\n\n#### Serializing defaults\n\nAPIs **must not** change the way a field with a default value is serialized. For\nexample if a field does not appear in the response if the value is equal to the\ndefault, the serialization **must not** change to include the field with the\ndefault. Clients may depend on the presence or absence of a field in a resource\nas semantically meaningful, so a change to how serialization is done for absent\nvalues **must not** occur in a minor version.\n\nConsider the following proto, where the default value of `wheels` is `2`:\n\n```proto\n// A representation of an automobile\nmessage Automobile {\n    // google.api.resource and other annotations and fields\n\n    // The number of wheels on the automobile.\n    // The default value is 2, when no value is sent by the client.\n    int wheels = 2;\n}\n```\n\nFirst the proto serializes to JSON when the value of `wheels` is `2` as follows:\n\n```json\n{\n    \"name\": \"my-car\"\n}\n```\n\nThen, the API service changes the serialization to include `wheel` even if the\nvalue is equal to the default value, `2` as follows:\n\n```json\n{\n    \"name\": \"my-car\",\n    \"wheels\": 2\n}\n```\n\nThis constitutes a change that is not backwards compatible within a major\nversion.\n\n## Further reading\n\n- For compatibility around field behavior, see [AIP-203][].\n- For compatibility around pagination, see [AIP-158][].\n- For compatibility around long-running operations, see [AIP-151][].\n- For understanding stability levels and expectations, see [AIP-181][].\n- For compatibility with client library resource name parsing, see [AIP-4231][]\n- For compatibility with client library method signatures, see [AIP-4232][]\n\n## Changelog\n\n- **2023-07-26**: Added reference to field behavior compatibility.\n- **2023-07-26**: Added note on APIs which have limited clients.\n- **2022-08-11**: Added \"Moving components between files\" section.\n- **2022-06-01**: Added more links to other AIPs with compatibility concerns\n- **2019-12-16**: Clarified that moving existing fields into oneofs is\n  breaking.\n\n<!-- prettier-ignore-start -->\n[aip-122]: ./0122.md\n[aip-151]: ./0151.md\n[aip-158]: ./0158.md\n[aip-181]: ./0181.md\n[aip-203]: ./0203.md\n[aip-4231]: ./client-libraries/4231.md\n[aip-4232]: ./client-libraries/4232.md\n[ec2]: https://aws.amazon.com/blogs/aws/theyre-here-longer-ec2-resource-ids-now-available/\n<!-- prettier-ignore-end -->\n"}
