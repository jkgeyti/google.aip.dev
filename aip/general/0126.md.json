{"text":"---\nid: 126\nstate: approved\ncreated: 2019-07-24\nplacement:\n  category: resource-design\n  order: 60\n---\n\n# Enumerations\n\nIt is common for a field to only accept or provide a discrete and limited set\nof values. In these cases, it can be useful to use enumerations (generally\nabbreviated \"enums\") in order to clearly communicate what the set of allowed\nvalues are.\n\n## Guidance\n\nAPIs **may** expose enum objects for sets of values that are expected to change\ninfrequently:\n\n```proto\n// A representation of a book.\nmessage Book {\n  // Other fields...\n\n  // Possible formats in which the book may be published.\n  enum Format {\n    // Default value. This value is unused.\n    FORMAT_UNSPECIFIED = 0;\n\n    // The printed format, in hardback.\n    HARDBACK = 1;\n\n    // The printed format, in paperback.\n    PAPERBACK = 2;\n\n    // An electronic book format.\n    EBOOK = 3;\n\n    // An audio recording.\n    AUDIOBOOK = 4;\n  }\n\n  // The format of the book.\n  Format format = 99;\n\n  // Other fields...\n}\n```\n\n- All enum values **must** use `UPPER_SNAKE_CASE`.\n- The first value of the enum **should** be the name of the enum itself\n  followed by the suffix `_UNSPECIFIED`.\n  - An exception to this rule is if there is a clearly useful zero value. In\n    particular, if an enum needs to present an `UNKNOWN`, it is usually clearer\n    and more useful for it to be a zero value rather than having both.\n- Enums which will only be used in a single message **should** be nested within that message. \n  In this case, the enum **should** be declared immediately before it is used.\n  - The non-zero values of such a nested enum definition **should not** be prefixed by the name \n    of the enum itself. This generally requires users to write `MyState.MYSTATE_ACTIVE` in their \n    code, which is unnecessarily verbose.\n- Enums which will be used by multiple messages **should** be defined at the package level and \n  **should** be defined at the bottom of the proto file (see [AIP-191][]).\n  - Some languages (including C++) hoist enum values into the parent namespace, which can result \n    in conflicts for enums with the same values in the same proto package. To avoid sharing values, \n    APIs **should** prefix package-level enum values with the name of the enum. \n- Enums **should** document whether the enum is frozen or they expect to add\n  values in the future.\n\n### When to use enums\n\nEnums can be more accessible and readable than strings or booleans in many\ncases, but they do add overhead when they change. Therefore, enums **should**\nreceive new values infrequently. While the definition of \"infrequently\" may\nchange based on individual use cases, a good rule of thumb is no more than once\na year. For enums that change frequently, the API **should** use a string and\ndocument the format.\n\nAdditionally, enums **should not** be used when there is a competing,\nwidely-adopted standard representation (such as with [language codes][bcp-47]\nor [media types][]).\n\n**Note:** If an enumerated value needs to be shared across APIs, an enum\n**may** be used, but the assignment between enum values and their corresponding\nintegers **must** match.\n\n### Alternatives\n\nFor enumerated values where the set of allowed values changes frequently, APIs\n**should** use a `string` field instead, and **must** document the allowed\nvalues. String fields with enumerated values **should** use `kebab-case` for\ntheir values.\n\nFor enumerated values where there is a competing, widely-adopted standard\nrepresentation (generally, but not necessarily, a string), that standard\nrepresentation **should** be used. This is true even if only a small subset of\nvalues are permitted, because using enums in this situation often leads to\nfrustrating lookup tables when trying to use multiple APIs together.\n\nBoolean fields **may** be used in situations where it is clear that no further\nflexibility will be needed. The default value **must** be `false`.\n\n**Note:** When using protocol buffers, it is impossible to distinguish between\n`false` and unset. If this is a requirement, an enum **may** be a better design\nchoice (although `google.protobuf.BoolValue` is also available).\n\n## Further reading\n\n- For states, a special type of enum, see [AIP-216][].\n\n[aip-191]: ./0191.md\n[aip-216]: ./0216.md\n[bcp-47]: https://en.wikipedia.org/wiki/IETF_language_tag\n[media types]: https://en.wikipedia.org/wiki/Media_type\n"}
