{"text":"---\nid: 129\nstate: approved\ncreated: 2023-09-20\nupdated: 2023-10-31\nplacement:\n  category: resource-design\n  order: 65\n---\n\n# Server-Modified Values and Defaults\n\nServices often provide default values for resource fields, and occasionally\nnormalize the user input before returning it in the response. The guidance\nherein describes how services document such behavior for the benefit of\nconsumers.\n\n## Guidance\n\n### Single Owner Fields\n\nFields **must** have a single owner, whether that is the client or the server.\nServer owned fields **must** be indicated with the `OUTPUT_ONLY` field_behavior.\nAll other types of fields **must** be considered to be owned by the client. The\nserver **must** respect the value (or lack thereof) for all client owned fields\nand not modify them.\n\n### Effective Values\n\nThere are instances where a service will allocate, generate, or calculate a\nvalue if the client chooses not to specify one. For example: a client creates a\nvirtual machine without specifying a static IP address for the virtual machine\nto be available on. Such a scenario is opting into dynamic IP address\nallocation.\n\nSome examples of these types of fields are ones that are:\n\n* generated (UUID)\n* allocated (dynamic IP address)\n* assigned (most recent software package version)\n\nAn attribute with an effective value ***must*** be expressed as two fields in\nthe API:\n* a mutable field that can be optionally set by the user and **must not** be\nmodified by the service\n* an `OUTPUT_ONLY` field that records the effective value decided on by the\nservice\n\nExample:\n```proto\nmessage VirtualMachine {\n  â€¦\n  string ip_address = 4;\n  string effective_ip_address = 5 [\n    (google.api.field_behavior) = OUTPUT_ONLY\n  ];\n}\n```\n\n#### Naming\n\nEffective values **must** be named by prefixing `effective_` to the mutable\nfield's name.\n\n### User-Specified Fields\n\nFor user-specified fields, the value in response from the service **must** be\nthe same as provided by the create or update request. For string fields this\nmeans returning the value unchanged, with one exception: \n\n* When a string field has a data type annotation, a normalized string that\n  represents the given value **may** be returned.\n\n### Normalizations\n\nA field that is normalized by the service **must** be annotated with the\n`google.api.field_info` extension. See [AIP-202](aip-202) for guidance on using\nthis extension The allowed set of normalizations includes the following formats:\n\n* uuid\n* ipv4\n* ipv6\n* email\n\nNormalizations on fields **must** be described using the `google.api.field_info`\nannotation.\n\n## Rationale\n\nServer-modified and default values often make it harder to implement\n[state-driven clients](state-driven-clients). These clients are often unable to\ntell when their desired state matches the current state for these fields, as the\nrules by which a server may modify and return values are complex, not public,\nand not repeatable.\n\n### Rationale for Single Owner Fields\n\nWhen fields do not have a single owner they can cause issues for\n[state-driven clients](state-driven-clients). These clients may attempt to set\nvalues for fields that are overwritten by server set values, leading to the\nclient entering an infinite loop to correct the change.\n\n### Rationale for Naming\n\nConsistent naming is important for identifying standard behavior across APIs\nand fields. Programmatic association between user-specified and effective values\ndepends on consistent naming.\n\n### Rationale for Normalizations\n\nNormalizations are important to allow services to store and return values in a\nstandard way while communicating to clients what changes are semantically\nidentical. Normalizing a value on the service side allows the service to accept\na wider range of semantically identical inputs without needing to maintain every\nvalue as a raw string. Surfacing the normalization that is being applied to\nclients allows for client side comparison of sent and retrieved values to check\nfor differences.\n\nFor example, in a resource that accepts an email address on a particular field\na client may specify a given email address in a variety of ways. For the email\n`ada@example.com` a client may choose to specify `ADA@example.com`,\n`aDa@example.com`, or `AdA@example.com`. These are semantically identical and\n*should* all be accepted by the service. The service then may choose to\nnormalize the email address for storage and retrieval through downcasing or\ncanonicalization. Importantly, the information surfaced to clients on the\nnormalization of a field will not describe the normalization algorithm itself,\nbut instead the comparison method used to accurately compute if two values\nshould be considered equal.\n\n### Rationale for Field Value Handling\n\nFor fields not using an allowed normalization,\n[Declarative clients][] will not be able to identify which changes are\nsemantically meaningful. When a [Declarative client][Declarative clients]\nsends a particular value it will ensure that the value is being returned by the\nservice to validate it was set correctly.\n\n## Changelog\n\n- **2023-10-31:** Update to approved.\n\n[Declarative clients]: ./0009#declarative-clients\n[aip-202]: ./202.md\n\n<!-- prettier-ignore-start -->\n[aip-180]: ./0180.md\n[state-driven-clients]: ./009.md#state-driven-clients\n<!-- prettier-ignore-end -->"}
