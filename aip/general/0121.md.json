{"text":"---\nid: 121\nstate: approved\ncreated: 2019-01-26\nplacement:\n  category: resource-design\n  order: 10\n---\n\n# Resource-oriented design\n\nResource-oriented design is a pattern for specifying [RPC][] APIs, based on\nseveral high-level design principles (most of which are common to recent public\nHTTP APIs):\n\n- The fundamental building blocks of an API are individually-named _resources_\n  (nouns) and the relationships and hierarchy that exist between them.\n- A small number of standard _methods_ (verbs) provide the semantics for most\n  common operations. However, custom methods are available in situations where\n  the standard methods do not fit.\n- Stateless protocol: Each interaction between the client and the server is\n  independent, and both the client and server have clear roles.\n\nReaders might notice similarities between these principles and some principles\nof [REST][]; resource-oriented design borrows many principles from REST, while\nalso defining its own patterns where appropriate.\n\n## Guidance\n\nWhen designing an API, consider the following (roughly in logical order):\n\n- The resources (nouns) the API will provide\n- The relationships and hierarchies between those resources\n- The schema of each resource\n- The methods (verbs) each resource provides, relying as much as possible on\n  the standard verbs.\n\n### Resources\n\nA resource-oriented API **should** generally be modeled as a resource\nhierarchy, where each node is either a simple resource or a collection of\nresources.\n\nA _collection_ contains resources of _the same type_. For example, a publisher\nhas the collection of books that it publishes. A resource usually has fields,\nand resources may have any number of sub-resources (usually collections).\n\n**Note:** While there is some conceptual alignment between storage systems and\nAPIs, a service with a resource-oriented API is not necessarily a database, and\nhas enormous flexibility in how it interprets resources and methods. API\ndesigners **should not** expect that their API will be reflective of their\ndatabase schema. In fact, having an API that is identical to the underlying\ndatabase schema is actually an anti-pattern, as it tightly couples the surface\nto the underlying system.\n\n### Methods\n\nResource-oriented APIs emphasize resources (data model) over the methods\nperformed on those resources (functionality). A typical resource-oriented API\nexposes a large number of resources with a small number of methods on each\nresource. The methods can be either the standard methods ([Get][], [List][],\n[Create][], [Update][], [Delete][]), or [custom methods][].\n\nIf the request to or the response from a standard method (or a custom method in\nthe same *service*) **is** the resource or **contains** the resource, the\nresource schema for that resource across all methods **must** be the same.\n\n| Standard method | Request               | Response        |\n| --------------- | --------------------- | --------------- |\n| Create          | Contains the resource | Is the resource |\n| Get             | None                  | Is the resource |\n| Update          | Contains the resource | Is the resource |\n| Delete          | None                  | None            |\n| List            | None                  | Is the resource |\n\n*The table above describes each standard method's relationship to the resource,\nwhere \"None\" indicates that the resource neither **is** nor **is contained** in\nthe request or the response*\n\nA resource **must** support at minimum [Get][]: clients must be\nable to validate the state of resources after performing a mutation such\nas [Create][], [Update][], or [Delete][].\n\nA resource **must** also support [List][], except for [singleton resources][]\nwhere more than one resource is not possible.\n\n**Note:** A custom method in resource-oriented design does _not_ entail\ndefining a new or custom HTTP verb. Custom methods use traditional HTTP verbs\n(usually `POST`) and define the custom verb in the URI.\n\nAPIs **should** prefer standard methods over custom methods; the purpose of\ncustom methods is to define functionality that does not cleanly map to any of\nthe standard methods. Custom methods offer the same design freedom as\ntraditional RPC APIs, which can be used to implement common programming\npatterns, such as database transactions, import and export, or data analysis.\n\n### Strong Consistency\n\nFor methods that operate on the [management plane][], the completion of those\noperations (either successful or with an error, LRO or synchronous) **must**\nmean that the state of the resource's existence and all user-settable values\nhave reached a steady-state.\n\n[output only][] values unrelated to the resource [state][] **should** also have\nreached a steady-state. for values that are related to the resource [state][].\n\nExamples include:\n\n- Following a successful create that is is latest mutation on a resource, a get\n  request for a resource **must** return the resource.\n- Following a successful update that is the latest mutation on a resource, a get\n  request for a resource **must** return the final values from the update\n  request.\n- Following a successful delete that is the latest mutation on a resource, a get\n  request for a resource **must** return `NOT_FOUND` (or the resource with the\n  `DELETED` state value in the case of [soft delete][])\n\nClients of resource-oriented APIs often need to orchestrate multiple operations\nin sequence (e.g. create resource A, create resource B which depends on A), and\nensuring that resources immediately reflect steady user state after an operation\nis complete ensures clients can rely on method completion as a signal to begin\nthe next operation.\n\n[output only][] fields ideally would follow the same guidelines, but as\nthese fields can often represent a resources live state, it's sometimes\nnecessary for these values to change after a successful mutation operation to\nreflect a state change.\n\n### Stateless protocol\n\nAs with most public APIs available today, resource-oriented APIs **must**\noperate over a [stateless protocol][]: The fundamental behavior of any\nindividual request is independent of other requests made by the caller.\nThis is to say, each request happens in isolation of other requests made by that\nclient or another, and resources exposed by an API are directly addressable\nwithout needing to apply a series of specific requests to \"reach\" the desired\nresource.\n\nIn an API with a stateless protocol, the server has the responsibility for\npersisting data, which may be shared between multiple clients, while clients\nhave sole responsibility and authority for maintaining the application state.\n\n### Cyclic References\n\nThe relationship between resources, such as parent-child or\n[resource references][], **must** be representable via a\n[directed acyclic graph][].\n\nA cyclic relationship between resources increases the complexity of managing\nresources. Consider resources A and B that refer to\neach other. The process to create said resources are:\n\n1. create resource A without a reference to B. Retrieve id for resource A.\n2. create resource B with a reference to A. Retrieve id for resource B.\n3. update resource A with the reference to B.\n\nThe delete operation may also become more complex, due to reasoning about which\nresource must be dereferenced first for a successful deletion.\n\nThis requirement does not apply to relationships that are expressed via\n[output only][] fields, as they do not require the user to specify the values\nand in turn do not increase resource management complexity.\n\n[create]: ./0133.md\n[custom methods]: ./0136.md\n[delete]: ./0135.md\n[directed acyclic graph]: https://en.wikipedia.org/wiki/Directed_acyclic_graph\n[get]: ./0131.md\n[list]: ./0132.md\n[management plane]: ./0111.md#management-plane\n[output only]: ./0203.md#output-only\n[rest]: https://en.wikipedia.org/wiki/Representational_state_transfer\n[resource references]: ./0122.md#fields-representing-another-resource\n[rpc]: https://en.wikipedia.org/wiki/Remote_procedure_call\n[singleton resources]: ./0156.md\n[soft delete]: ./0164.md\n[state]: ./0216.md\n[stateless protocol]: https://en.wikipedia.org/wiki/Stateless_protocol\n[update]: ./0134.md\n\n\n## Changelog\n\n- **2023-08-24**: Added guidance on consistency guarantees of methods.\n- **2023-07-23**: Clarify stateless protocol definition.\n- **2023-01-21**: Explicitly require matching schema across standard methods.\n- **2022-12-19**: Added a section requiring Get and List.\n- **2022-11-02**: Added a section restricting resource references.\n- **2019-08-01**: Changed the examples from \"shelves\" to \"publishers\", to\n  present a better example of resource ownership."}
