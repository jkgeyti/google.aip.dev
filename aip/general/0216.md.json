{"text":"---\nid: 216\nstate: approved\ncreated: 2018-10-01\nupdated: 2022-06-02\nplacement:\n  category: fields\n  order: 110\n---\n\n# States\n\nMany API resources carry a concept of \"state\": ordinarily, the resource's place\nin its life cycle. For example, a virtual machine may be being provisioned,\navailable for use, being spun down, or potentially be in one of several other\nsituations. A job or query may be preparing to run, be actively running, have\ncompleted, and so on.\n\n## Guidance\n\nResources needing to communicate their state **should** use an enum, which\n**should** be called `State` (or, if more specificity is required, end in the\nword `State`). This enum **should** be nested within the message it describes\nwhen only used as a field within that message.\n\n**Important:** We use the term `State`, and _not_ `Status` (which is reserved\nfor the HTTP and gRPC statuses).\n\n### Enum values\n\nIdeally, Google APIs use the same terminology throughout when expressing the\nsame semantic concepts. There are usually many words available to express a\ngiven state, but our customers often use multiple APIs together, and it is\neasier for them when our terms are consistent.\n\nAt a high level:\n\n- Resources that are available for use are `ACTIVE` (preferred over terms such\n  as \"ready\" or \"available\").\n- Resources that have completed a (usually terminal) requested action use past\n  participles (usually ending in `-ED`), such as `SUCCEEDED` (not\n  \"successful\"), `FAILED` (not \"failure\"), `DELETED`, `SUSPENDED`, and so on.\n- Resources that are currently undergoing a state change use present\n  participles (usually ending in `-ING`), such as `RUNNING`, `CREATING`,\n  `DELETING`, and so on. In this case, it is expected that the state is\n  temporary and will resolve to another state on its own, with no further user\n  action.\n\n**Note:** Remember to only add states that are useful to customers. Exposing a\nlarge number of states simply because they exist in your internal system is\nunnecessary and adds confusion for customers. Each state must come with a use\ncase for why it is necessary.\n\n### Output only\n\nThe field referencing the `State` enum in a resource **should** behave and be\ndocumented as \"Output only\", in accordance with [AIP-203](./0203.md).\n\nAPIs **should not** allow a `State` enum to be directly updated through an\n\"update\" method (or directly set through the \"create\" method), and **should**\ninstead use custom state transition methods.\n\nThis is because update methods are generally not expected to have side effects,\nand also because updating state directly implies that it is possible to set the\nstate to any available value, whereas states generally reflect a resource's\nprogression through a lifecycle.\n\n### State transition methods\n\nState transition methods are a special type of custom method that are\nresponsible for transitioning a state field from one enum value to another. As\npart of the transition, other fields may also change, e.g. an `update_time`\nfield. The method definition should look like the following:\n\n```proto\n// Publishes a book.\n// The `state` of the book after publishing is `PUBLISHED`.\n// `PublishBook` can be called on Books in the state `DRAFT`; Books in a\n// different state (including `PUBLISHED`) returns an error.\nrpc PublishBook(PublishBookRequest) returns (Book) {\n  option (google.api.http) = {\n    post: \"/v1/{name=publishers/*/books/*}:publish\"\n    body: \"*\"\n  };\n}\n```\n\n- The name of the method **should** be a verb followed by the singular form of\n  the resource's message name.\n- The request message **must** match the RPC name, with a `Request` suffix.\n- The response message **should** be the resource itself.\n  - If the RPC is [long-running][], the response message **should** be a\n    `google.longrunning.Operation` which resolves to the resource itself.\n- The HTTP verb **must** be `POST`.\n- The HTTP URI **must** use a `:` character followed by the custom verb\n  (`:publish` in the above example), and the verb in the URI **must** match the\n  verb in the name of the RPC.\n  - If word separation is required, `camelCase` **must** be used.\n- The `body` clause in the `google.api.http` annotation **must** be `\"*\"`.\n- The request message field receiving the resource name **should** map to the\n  URI path.\n  - This field **should** be called `name`.\n  - The `name` field **should** be the only variable in the URI path. All\n    remaining parameters **should** map to URI query parameters.\n- If the state transition is not allowed, the service **must** error with\n  `FAILED_PRECONDITION` (HTTP 400).\n\nThe request message should look like this:\n\n```proto\nmessage PublishBookRequest {\n  // The name of the book to publish.\n  // Format: publishers/{publisher}/books/{book}\n  string name = 1 [\n    (google.api.field_behavior) = REQUIRED,\n    (google.api.resource_reference) = {\n      type: \"library.googleapis.com/Book\"\n    }];\n}\n```\n\n- A resource name field **must** be included. It **should** be called `name`.\n- The comment for the field **should** document the resource pattern.\n- Other fields **may** be included.\n\n## Additional Guidance\n\n### Default value\n\nThe zero value of each state enum **should** adhere to the following\nconvention:\n\n```proto\nenum State {\n  // The default value. This value is used if the state is omitted.\n  STATE_UNSPECIFIED = 0;\n\n  // Other values...\n}\n```\n\nResources **should not** provide an unspecified state to users, and this value\n**should not** actually be used.\n\n### Value uniqueness\n\nMultiple top-level enums within the same package **must** not share the same\nvalues. This is because the C++ protoc code generator flattens top-level enum\nvalues into a single namespace.\n\nState enums **should** live inside the resource definition.\n\n### Prefixes\n\nUsing a `STATE_` prefix on every enum value is unnecessary. State enum values\n**should not** be prefixed with the enum name, except for the default value\n`STATE_UNSPECIFIED`.\n\n### Breaking changes\n\n**TL;DR:** Clearly communicate to users that state enums may receive new values\nin the future, and be conscientious about adding states to an existing enum.\n\nEven though adding states to an existing states enum _can_ break existing user\ncode, adding states is not considered a breaking change. Consider a state with\nonly two values: `ACTIVE` and `DELETED`. A user may add code that checks\n`if state == ACTIVE`, and in the else cases simply assumes the resource is\ndeleted. If the API later adds a new state for another purpose, that code will\nbreak.\n\nWe ultimately can not control this behavior, but API documentation **should**\nactively encourage users to code against state enums with the expectation that\nthey may receive new values in the future.\n\nAPIs **may** add new states to an existing State enum when appropriate, and\nadding a new state is _not_ considered a breaking change.\n\n### When to avoid states\n\nSometimes, a `State` enum may not be what is best for your API, particularly in\nsituations where a state has a very small number of potential values, or when\nstates are not mutually exclusive.\n\nConsider the example of a state with only `ACTIVE` and `DELETED`, as discussed\nabove. In this situation, the API may be better off exposing a\n`google.protobuf.Timestamp delete_time`, and instructing users to rely on\nwhether it is set to determine deletion.\n\n### Common states\n\nThe following is a list of states in common use. APIs **should** consider prior\nart when determining state names, and **should** value local consistency above\nglobal consistency in the case of conflicting precedent.\n\n#### Resting states\n\n\"Resting states\" are lifecycle states that, absent user action, are expected to\nremain indefinitely. However, the user can initiate an action to move a\nresource in a resting state into certain other states (resting or active).\n\n- `ACCEPTED`\n- `ACTIVE`\n- `CANCELLED`\n- `DELETED`\n- `FAILED`\n- `SUCCEEDED`\n- `SUSPENDED`\n- `VERIFIED`\n\n#### Active states\n\n\"Active states\" are lifecycle states that typically resolve on their own into a\nsingle expected resting state.\n\n**Note:** Remember only to expose states that are useful to customers. Active\nstates are valuable only if the resource will be in that state for a sufficient\nperiod of time. If state changes are immediate, active states are not\nnecessary.\n\n- `CREATING` (usually becomes `ACTIVE`)\n- `DELETING` (usually becomes `DELETED`)\n- `PENDING` (usually becomes `RUNNING`)\n- `REPAIRING` (usually becomes `ACTIVE`)\n- `RUNNING` (usually becomes `SUCCEEDED`)\n- `SUSPENDING` (usually becomes `SUSPENDED`)\n\n## Further reading\n\n- For information on enums generally, see [AIP-126][].\n\n## Changelog\n\n- **2022-06-02:** Changed suffix descriptions to eliminate superfluous \"-\".\n- **2020-10-20**: Added guidance on prefixing enum values with enum name.\n- **2020-09-02**: Clarified that states are not directly set on create either.\n- **2019-12-05**: Changed guidance on state transition methods, downgrading\n  **must** to **should** on the response type.\n- **2019-08-16**: Added guidance for state transition methods.\n- **2019-07-18**: Added explicit guidance on the unspecified value.\n\n[aip-126]: ./0126.md\n[long-running]: ./0151.md\n"}
